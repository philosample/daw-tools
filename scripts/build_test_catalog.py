#!/usr/bin/env python3
from __future__ import annotations

import argparse
import ast
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable

ROOT = Path(__file__).resolve().parents[1]
DOC_CATALOG = ROOT / "docs" / "TEST_CATALOG.md"
DEFAULT_MAP = ROOT / "tests" / "coverage_map.yaml"

SQL_RE = re.compile(r"\\b(SELECT|INSERT|UPDATE|DELETE)\\b", re.IGNORECASE)


@dataclass
class Item:
    kind: str
    name: str
    file: str
    line: int
    note: str
    tests: list[str]


def relpath(path: Path) -> str:
    return str(path.relative_to(ROOT))


def iter_py_files(paths: Iterable[Path]) -> Iterable[Path]:
    for base in paths:
        if base.is_file() and base.suffix == ".py":
            yield base
        elif base.is_dir():
            for path in base.rglob("*.py"):
                yield path


def default_tests_for_file(path: str) -> list[str]:
    if path.endswith("abletools_scan.py"):
        return ["pytest -q tests/test_scan.py", "./scripts/test_full_scan.sh"]
    if path.endswith("abletools_ui.py"):
        return ["pytest -q tests/test_ui_helpers.py"]
    if path.endswith("abletools_prefs.py"):
        return ["pytest -q tests/test_prefs.py"]
    if path.endswith("abletools_catalog_db.py"):
        return ["pytest -q tests/test_catalog_db.py"]
    if path.endswith("abletools_schema_validate.py"):
        return ["python3 abletools_schema_validate.py --help"]
    if path.endswith("abletools_analytics.py"):
        return ["python3 abletools_analytics.py --help"]
    if path.endswith("abletools_maintenance.py"):
        return ["python3 abletools_maintenance.py --help"]
    return []


def collect_items(paths: Iterable[Path]) -> list[Item]:
    items: list[Item] = []
    for path in iter_py_files(paths):
        rel = relpath(path)
        try:
            text = path.read_text(encoding="utf-8")
        except Exception:
            continue
        try:
            tree = ast.parse(text)
        except SyntaxError:
            continue

        tests = default_tests_for_file(rel)
        items.append(
            Item(
                kind="file",
                name=rel,
                file=rel,
                line=1,
                note="module entry",
                tests=tests,
            )
        )

        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                items.append(
                    Item(
                        kind="function",
                        name=node.name,
                        file=rel,
                        line=node.lineno or 1,
                        note="",
                        tests=tests,
                    )
                )
            elif isinstance(node, ast.ClassDef):
                items.append(
                    Item(
                        kind="class",
                        name=node.name,
                        file=rel,
                        line=node.lineno or 1,
                        note="",
                        tests=tests,
                    )
                )

        for idx, line in enumerate(text.splitlines(), start=1):
            if "SELECT" in line.upper() and SQL_RE.search(line):
                items.append(
                    Item(
                        kind="query",
                        name=line.strip()[:80],
                        file=rel,
                        line=idx,
                        note="sql",
                        tests=tests,
                    )
                )

    return items


def write_yaml(items: list[Item], out_path: Path) -> None:
    lines = ["items:"]
    for item in items:
        lines.append("  - kind: {}".format(item.kind))
        lines.append("    name: {}".format(item.name.replace("\n", " ")))
        lines.append("    file: {}".format(item.file))
        lines.append("    line: {}".format(item.line))
        lines.append("    note: {}".format(item.note))
        if item.tests:
            lines.append("    tests:")
            for test in item.tests:
                lines.append("      - {}".format(test))
        else:
            lines.append("    tests: []")
    out_path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def write_catalog(items: list[Item], out_path: Path) -> None:
    by_file: dict[str, list[Item]] = {}
    for item in items:
        by_file.setdefault(item.file, []).append(item)

    lines = ["# Query / Function / File Catalog", ""]
    lines.append("Generated by `scripts/build_test_catalog.py`.")
    lines.append("")
    for file in sorted(by_file):
        lines.append(f"## {file}")
        for item in by_file[file]:
            label = f"{item.kind}: {item.name}"
            if item.kind in {"function", "class", "query"}:
                label += f" (L{item.line})"
            lines.append(f"- {label}")
        lines.append("")
    out_path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--paths",
        nargs="*",
        default=[
            "abletools_scan.py",
            "abletools_catalog_db.py",
            "abletools_prefs.py",
            "abletools_ui.py",
            "abletools_schema_validate.py",
            "abletools_analytics.py",
            "abletools_maintenance.py",
            "ramify_core.py",
            "ableton_ramify.py",
        ],
        help="Paths to scan for test catalog generation.",
    )
    parser.add_argument(
        "--map-out",
        default=str(DEFAULT_MAP),
        help="Coverage map output path.",
    )
    parser.add_argument(
        "--catalog-out",
        default=str(DOC_CATALOG),
        help="Catalog markdown output path.",
    )
    args = parser.parse_args()

    paths = [ROOT / Path(p) for p in args.paths]
    items = collect_items(paths)
    schema_paths = list((ROOT / "schemas").glob("*.schema.json"))
    for schema in schema_paths:
        rel = relpath(schema)
        items.append(
            Item(
                kind="schema",
                name=schema.name,
                file=rel,
                line=1,
                note="schema file",
                tests=[
                    "pytest -q tests/test_schema_fixtures.py",
                    "./scripts/test_full_scan.sh",
                    "./scripts/test_targeted_scan.sh",
                ],
            )
        )
    sql_paths = list(ROOT.rglob("*.sql"))
    for sql_path in sql_paths:
        rel = relpath(sql_path)
        items.append(
            Item(
                kind="sql_file",
                name=sql_path.name,
                file=rel,
                line=1,
                note="sql file",
                tests=["pytest -q tests/test_catalog_db.py"],
            )
        )
    write_yaml(items, Path(args.map_out))
    write_catalog(items, Path(args.catalog_out))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
